from numpy.lib.arraysetops import unique
import pandas as pd
import numpy as np
import difflib
import re

# this function calls makes a list of all the unique songs in the UIL data with event and composer


def create_pml_match_df():
    uil_data = pd.read_csv('all_results.csv', encoding='utf-8')
    uil_data.fillna(' ', inplace=True)
    unique_songs = uil_data.melt(id_vars=['Event'], value_vars=[
                                 'Title 1', 'Title 2', 'Title 3'])
    unique_songs['composer'] = uil_data.melt(id_vars=['Event'], value_vars=[
                                             'Composer 1', 'Composer 2', 'Composer 3'])['value']
    unique_songs = unique_songs.dropna()
    unique_songs = unique_songs[unique_songs['value'] != ' ']
    # event column reqpeats 3 times in column
    unique_songs = unique_songs.reset_index(drop=True)
    unique_songs = unique_songs.drop_duplicates()
    unique_songs = unique_songs.reset_index(drop=True)
    unique_songs['code'] = ''
    # change column names
    unique_songs = unique_songs.rename(
        columns={'value': 'title'})
    # drop variable column
    unique_songs = unique_songs.drop(columns=['variable'])

    unique_songs.to_csv('pml_match.csv', index=False)
    return unique_songs


# check to see if pml_matches.csv exists
try:
    pml_matches = pd.read_csv('pml_matches.csv')
except:
    create_pml_match_df().to_csv('pml_matches.csv', index=False)

# read in pml_matches.csv
pml_matches = pd.read_csv('pml_matches.csv')

# read in pml.csv
pml = pd.read_csv('pml.csv', encoding='utf-8')

# pml only where event name contains chorus
pml_chorus = pml[pml['Event Name'].str.contains('Chorus')]

# this function uses difflib.get_close_matches to find close matches to each song in pml_matches
# retrun pml['code'] of that row
# save after each song is matched
# only check songs that don't have a code yet


def get_close_matches():
    pml.fillna('', inplace=True)
    pml_matches.fillna('', inplace=True)
    pml['concat'] = pml['Title'] + ' ' + pml['Composer']
    pml_song = pml['concat']

    # pml_song to list for each event type with "chorus" in the name
    mixed_songs = pml_song[pml['Event Name'].str.contains('Mixed')].tolist()
    mixed_songs = [str(x) for x in mixed_songs]

    treble_songs = pml_song[pml['Event Name'].str.contains('Treble')].tolist()
    treble_songs = [str(x) for x in treble_songs]

    tenor_bass_songs = pml_song[pml['Event Name'].str.contains(
        'Tenor-Bass')].tolist()
    tenor_bass_songs = [str(x) for x in tenor_bass_songs]

    # loop through pml_matches
    for index, row in pml_matches.iterrows():
        # check if code is empty
        if row['code'] == '':
            song1 = row['title'] + ' ' + row['composer']
            # remove any characters inside brackets
            song1 = re.sub(r'\([^)]*\)', '', song1)
            # remove any brackets
            song1 = re.sub(r'\[', '', song1)
            song1 = re.sub(r'\]', '', song1)
            # remove any characters inside curly brackets
            song1 = re.sub(r'\{[^)]*\}', '', song1)
            # remove any curly brackets
            song1 = re.sub(r'\{', '', song1)
            song1 = re.sub(r'\}', '', song1)

            if row['Event'].find('Mixed') != -1:
                close_matches = difflib.get_close_matches(
                    song1, mixed_songs, n=1, cutoff=0.7)
                try:
                    code = pml[(pml['concat'] == close_matches[0]) & (pml['Event Name'] == 'Mixed Chorus')]['Code'].tolist()[
                        0]
                except Exception:
                    # rettry code with any characters inside parentheses removed
                    try:
                        song1 = re.sub(r'\([^)]*\)', '', song1)
                        # remove parentheses
                        song1 = re.sub(r'\(', '', song1)

                        close_matches = difflib.get_close_matches(
                            song1, mixed_songs, n=1, cutoff=0.7)
                        code = pml[(pml['concat'] == close_matches[0]) & (pml['Event Name'] == 'Mixed Chorus')]['Code'].tolist()[
                            0]
                    except Exception:
                        code = ''

            elif row['Event'].find('Treble') != -1:
                close_matches = difflib.get_close_matches(
                    song1, treble_songs, n=1, cutoff=0.7)
                try:
                    code = pml[(pml['concat'] == close_matches[0]) & (pml['Event Name'] == 'Treble Chorus')]['Code'].tolist()[
                        0]
                except Exception:
                    try:
                        song1 = re.sub(r'\([^)]*\)', '', song1)
                        # remove parentheses
                        song1 = re.sub(r'\(', '', song1)

                        close_matches = difflib.get_close_matches(
                            song1, treble_songs, n=1, cutoff=0.7)
                        code = pml[(pml['concat'] == close_matches[0]) & (pml['Event Name'] == 'Treble Chorus')]['Code'].tolist()[
                            0]
                    except Exception:
                        code = ''

            elif row['Event'].find('Bass') != -1:
                close_matches = difflib.get_close_matches(
                    song1, tenor_bass_songs, n=1, cutoff=0.7)
                try:
                    code = pml[(pml['concat'] == close_matches[0]) & (pml['Event Name'] == 'Tenor-Bass Chorus')]['Code'].tolist()[
                        0]
                except Exception:
                    try:
                        song1 = re.sub(r'\([^)]*\)', '', song1)
                        # remove parentheses
                        song1 = re.sub(r'\(', '', song1)
                        close_matches = difflib.get_close_matches(
                            song1, tenor_bass_songs, n=1, cutoff=0.7)
                        code = pml[(pml['concat'] == close_matches[0]) & (pml['Event Name'] == 'Tenor-Bass Chorus')]['Code'].tolist()[
                            0]
                    except Exception:
                        code = ''

            else:
                print(f'no event match for {row}')
                close_matches = []

            # if code begins with 100, print error
            if code.startswith('100'):
                print(f'code starts with 100: {code}')

            # return pml index of close matches

            pml_matches.loc[index, 'code'] = code
            # every 1000 rows save
            if index % 1000 == 0:
                pml_matches.to_csv('pml_matches.csv', index=False)
                print(f'{index} rows saved')
                # print percent complete
                print(f'{index/len(pml_matches)*100}% complete')

    # save after loop
    pml_matches.to_csv('pml_matches.csv', index=False)


get_close_matches()


try:
    all_results_with_codes = pd.read_csv('all_results_with_codes.csv')
except:

    all_results_with_codes = pd.read_csv(
        'all_results_manip_std_dev.csv', encoding='utf-8')

    # add code 1, code 2, code 3 columns
    all_results_with_codes['code 1'] = ''
    all_results_with_codes['code 2'] = ''
    all_results_with_codes['code 3'] = ''

# read in pml_matches.csv
pml_matches = pd.read_csv('pml_matches.csv')

# fill na with empty string
all_results_with_codes.fillna('', inplace=True)

# loop through all_results_with_codes
for index, row in all_results_with_codes.iterrows():
    # check if code is empty
    if row['code 1'] == '':
        # get title 1
        title1 = row['Title 1']
        # get composer 1
        composer1 = row['Composer 1']
        # get event
        event = row['Event']

        try:
            code1 = pml_matches[(pml_matches['title'] == title1) & (
                pml_matches['composer'] == composer1) & (pml_matches['Event'] == event)]['code'].tolist()[0]
        except Exception:
            code1 = ''
    # get title 2, comp 2, code 2 also all the 3s
    if row['code 2'] == '':
        title2 = row['Title 2']
        composer2 = row['Composer 2']
        event = row['Event']
        try:
            code2 = pml_matches[(pml_matches['title'] == title2) & (
                pml_matches['composer'] == composer2) & (pml_matches['Event'] == event)]['code'].tolist()[0]
        except Exception:
            code2 = ''
    # check if code 3 is na
    if row['code 3'] == '':

        title3 = row['Title 3']
        composer3 = row['Composer 3']
        event = row['Event']
        try:
            code3 = pml_matches[(pml_matches['title'] == title3) & (
                pml_matches['composer'] == composer3) & (pml_matches['Event'] == event)]['code'].tolist()[0]
        except Exception:
            code3 = ''

    # add code 1, code 2, code 3 to all_results_with_codes
    try:
        all_results_with_codes.loc[index, 'code 1'] = code1
    except Exception:
        pass
    try:
        all_results_with_codes.loc[index, 'code 2'] = code2
    except Exception:
        pass
    try:
        all_results_with_codes.loc[index, 'code 3'] = code3
    except Exception:
        pass

    # save every 1000 rows
    if index % 1000 == 0:
        all_results_with_codes.to_csv(
            'all_results_with_codes.csv', index=False)
        print(f'{index} rows saved')
        # print percent complete
        print(f'{index/len(all_results_with_codes)*100}% complete')

# save after loop
all_results_with_codes.to_csv('all_results_with_codes.csv', index=False)

# read in all_results_with_codes.csv
all_results_with_codes = pd.read_csv(
    'all_results_with_codes.csv', encoding='utf-8')
